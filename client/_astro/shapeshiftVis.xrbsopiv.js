import{j as G}from"./jsx-runtime.D_zvdyIk.js";import{r as _}from"./index.RH_Wq4ov.js";import{g as y,h as U,i as Z,T as J,B as K,F as W,j as Q,b as X,S as Y,C as $,k as N,A as ee,D as te,P as ne,W as ie,f as se,l as oe,O as ae}from"./OrbitControls.Bn8mG_4i.js";import{A as re}from"./AsciiEffect.8R29u7ks.js";import{a as le}from"./simplex-noise.1Zj9OLGt.js";const b=0,ce=1,he=new y,q=new U,V=new Z,B=new y,P=new J;class de{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new I,this.unassigned=new I,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.vertices.push(new ue(e[t]));this.compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(i){const s=i.geometry;if(s!==void 0){const n=s.attributes.position;if(n!==void 0)for(let a=0,o=n.count;a<o;a++){const c=new y;c.fromBufferAttribute(n,a).applyMatrix4(i.matrixWorld),t.push(c)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let i=0,s=t.length;i<s;i++)if(t[i].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const i=this.faces;let s=-1/0,n=1/0;for(let a=0,o=i.length;a<o;a++){const c=i[a],r=c.distanceToPoint(e.origin),p=c.normal.dot(e.direction);if(r>0&&p>=0)return null;const f=p!==0?-r/p:0;if(!(f<=0)&&(p>0?n=Math.min(f,n):s=Math.max(f,s),s>n))return null}return s!==-1/0?e.at(s,t):e.at(n,t),t}intersectsRay(e){return this.intersectRay(e,he)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let i=e.outside;for(;i.next!==null&&i.next.face===e;)i=i.next;return this.assigned.removeSubList(t,i),t.prev=i.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const i=this.removeAllVerticesFromFace(e);if(i!==void 0)if(t===void 0)this.unassigned.appendChain(i);else{let s=i;do{const n=s.next;t.distanceToPoint(s.point)>this.tolerance?this.addVertexToFace(s,t):this.unassigned.append(s),s=n}while(s!==null)}return this}resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const i=t.next;let s=this.tolerance,n=null;for(let a=0;a<e.length;a++){const o=e[a];if(o.mark===b){const c=o.distanceToPoint(t.point);if(c>s&&(s=c,n=o),s>1e3*this.tolerance)break}}n!==null&&this.addVertexToFace(t,n),t=i}while(t!==null)}return this}computeExtremes(){const e=new y,t=new y,i=[],s=[];for(let n=0;n<3;n++)i[n]=s[n]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let n=0,a=this.vertices.length;n<a;n++){const o=this.vertices[n],c=o.point;for(let r=0;r<3;r++)c.getComponent(r)<e.getComponent(r)&&(e.setComponent(r,c.getComponent(r)),i[r]=o);for(let r=0;r<3;r++)c.getComponent(r)>t.getComponent(r)&&(t.setComponent(r,c.getComponent(r)),s[r]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:i,max:s}}computeInitialHull(){const e=this.vertices,t=this.computeExtremes(),i=t.min,s=t.max;let n=0,a=0;for(let l=0;l<3;l++){const d=s[l].point.getComponent(l)-i[l].point.getComponent(l);d>n&&(n=d,a=l)}const o=i[a],c=s[a];let r,p;n=0,q.set(o.point,c.point);for(let l=0,d=this.vertices.length;l<d;l++){const u=e[l];if(u!==o&&u!==c){q.closestPointToPoint(u.point,!0,B);const h=B.distanceToSquared(u.point);h>n&&(n=h,r=u)}}n=-1,V.setFromCoplanarPoints(o.point,c.point,r.point);for(let l=0,d=this.vertices.length;l<d;l++){const u=e[l];if(u!==o&&u!==c&&u!==r){const h=Math.abs(V.distanceToPoint(u.point));h>n&&(n=h,p=u)}}const f=[];if(V.distanceToPoint(p.point)<0){f.push(v.create(o,c,r),v.create(p,c,o),v.create(p,r,c),v.create(p,o,r));for(let l=0;l<3;l++){const d=(l+1)%3;f[l+1].getEdge(2).setTwin(f[0].getEdge(d)),f[l+1].getEdge(1).setTwin(f[d+1].getEdge(0))}}else{f.push(v.create(o,r,c),v.create(p,o,c),v.create(p,c,r),v.create(p,r,o));for(let l=0;l<3;l++){const d=(l+1)%3;f[l+1].getEdge(2).setTwin(f[0].getEdge((3-l)%3)),f[l+1].getEdge(0).setTwin(f[d+1].getEdge(1))}}for(let l=0;l<4;l++)this.faces.push(f[l]);for(let l=0,d=e.length;l<d;l++){const u=e[l];if(u!==o&&u!==c&&u!==r&&u!==p){n=this.tolerance;let h=null;for(let E=0;E<4;E++){const C=this.faces[E].distanceToPoint(u.point);C>n&&(n=C,h=this.faces[E])}h!==null&&this.addVertexToFace(u,h)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const i=this.faces[t];i.mark===b&&e.push(i)}return this.faces=e,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const i=this.assigned.first().face;let s=i.outside;do{const n=i.distanceToPoint(s.point);n>t&&(t=n,e=s),s=s.next}while(s!==null&&s.face===i);return e}}computeHorizon(e,t,i,s){this.deleteFaceVertices(i),i.mark=ce;let n;t===null?n=t=i.getEdge(0):n=t.next;do{const a=n.twin,o=a.face;o.mark===b&&(o.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,a,o,s):s.push(n)),n=n.next}while(n!==t);return this}addAdjoiningFace(e,t){const i=v.create(e,t.tail(),t.head());return this.faces.push(i),i.getEdge(-1).setTwin(t.twin),i.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let i=null,s=null;for(let n=0;n<t.length;n++){const a=t[n],o=this.addAdjoiningFace(e,a);i===null?i=o:o.next.setTwin(s),this.newFaces.push(o.face),s=o}return i.next.setTwin(s),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();(e=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}class v{constructor(){this.normal=new y,this.midpoint=new y,this.area=0,this.constant=0,this.outside=null,this.mark=b,this.edge=null}static create(e,t,i){const s=new v,n=new H(e,s),a=new H(t,s),o=new H(i,s);return n.next=o.prev=a,a.next=n.prev=o,o.next=a.prev=n,s.edge=n,s.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),i=this.edge.next.head();return P.set(e.point,t.point,i.point),P.getNormal(this.normal),P.getMidpoint(this.midpoint),this.area=P.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class H{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class ue{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class I{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class D extends K{constructor(e=[]){super();const t=[],i=[],n=new de().setFromPoints(e).faces;for(let a=0;a<n.length;a++){const o=n[a];let c=o.edge;do{const r=c.head().point;t.push(r.x,r.y,r.z),i.push(o.normal.x,o.normal.y,o.normal.z),c=c.next}while(c!==o.edge)}this.setAttribute("position",new W(t,3)),this.setAttribute("normal",new W(i,3))}}const L=le();function pe(x){let e,t,i,s,n,a,o,c,r=1,p=0,f=1.9,l=1.55,d=new y(0,1.25,5);function u(){e=new Y,e.background=new $(255,255,0),n=new N(15732735,3,100),n.position.set(d.x,d.y+500,d.z+500),n.color.set(16711680),e.add(n);const m=new N(16777215,3,500);m.position.set(d.x-500,d.y-500,d.z-500),m.color.set(255),e.add(m);const w=new ee(4210752,.5);e.add(w);const g=new te(16777215,.5);g.position.set(5,5,5),e.add(g),t=new ne(60,window.innerWidth/window.innerHeight,.1,50),t.position.z=2.5,i=new ie({alpha:!0}),i.setSize(window.innerWidth,window.innerHeight),i.setClearColor(12632256,0);const F=" ♡❣♥☺x6☹%&*⛆@#❤☺☻  ",z={invert:!0,resolution:.175,scale:1,color:!1,block:!0},T=HTMLCanvasElement.prototype.getContext;if(HTMLCanvasElement.prototype.getContext=function(M,S){return M==="2d"&&(S=S||{},S.willReadFrequently=!0),T.call(this,M,S)},a=new re(i,F,z),a.setSize(window.innerWidth,window.innerHeight),HTMLCanvasElement.prototype.getContext=T,a.domElement&&a.domElement.querySelector&&a.domElement.querySelector("canvas")){const M=a.domElement.querySelector("canvas");M.getContext&&M.getContext("2d",{willReadFrequently:!0})}document.getElementById(x).appendChild(a.domElement);const O=new se;new oe(O,{steps:1,depth:.15,bevelEnabled:!0,bevelThickness:.1,bevelSize:.2,bevelOffset:0,bevelSegments:10}).center(),s=new ae(t,a.domElement),s.enableDamping=!0,s.dampingFactor=.2,s.enableZoom=!1,s.rotateSpeed=5,s.zoomSpeed=1.2,s.panSpeed=.8,s.dynamicDampingFactor=.2,s.staticMoving=!1,window.addEventListener("resize",A,!1),j(k())}let h=k(),E=Date.now();function C(){requestAnimationFrame(C);let m=Date.now();if(m-E>2e3){if(E=m,Math.random()<.5&&h.points.length>5)h.points.pop();else{const g=h.points[Math.floor(Math.random()*h.points.length)];h.points.push(new y().copy(g))}h.shape.geometry.dispose(),h.shape.geometry=new D(h.points)}let w=Date.now()*1e-4;if(h.points.forEach((g,F)=>{g.x+=L(F,w,0)*.1,g.y+=L(w,F,1)*.1,g.z+=L(F,w,2)*.1}),h.shape.geometry.dispose(),h.shape.geometry=new D(h.points),n&&n.position){const g=Date.now()*25e-5;n.position.z=n.position.z+Math.sin(g)*.01,n.position.x=Math.sin(g)*500,n.position.y=250+Math.sin(g*1.5)*250,n.position.z=250+Math.cos(g*1.5)*250}o&&((o.scale.x>=f&&r>0||o.scale.x<=l&&r<0)&&(r*=-1),o.scale.x+=p*r,o.scale.y+=p*r,o.scale.z+=p*r,o.rotation.x+=.008,o.rotation.y+=.009,o.rotation.z+=.007),s.update(),a.render(e,t)}function A(){console.log("width: ",window.innerWidth),console.log("height: ",window.innerWidth),t.aspect=window.innerWidth/window.innerHeight,t.updateProjectionMatrix(),a.setSize(window.innerWidth,window.innerHeight)}function R(){window.removeEventListener("resize",A),cancelAnimationFrame(c);const m=document.getElementById(x);m&&a.domElement&&m.removeChild(a.domElement)}function j({shape:m,centroid:w}){if(!m||!w){console.error("Invalid shape or centroid provided to switchShape");return}m&&w?(o&&(e.remove(o),o.geometry&&o.geometry.dispose(),o.material&&o.material.dispose()),o=m,e.add(o),n&&n.position.set(w.x,w.y,w.z)):console.error("Invalid shape or centroid provided to switchShape")}function k(){const m=[];for(let T=0;T<20;T++)m.push(new y(Math.random()*2-1,Math.random()*2-1,Math.random()*2-1));const w=new D(m),g=new Q({color:16711935,wireframe:!0}),F=new X(w,g),z=new y(0,0,0);return{shape:F,centroid:z,points:m}}return u(),C(),{dispose:R,switchShape:j}}function ye({containerId:x="shapeshiftContainer1"}){return _.useEffect(()=>{const e=pe(x);return()=>{e&&e.dispose&&e.dispose()}},[x]),G.jsx("div",{id:x,className:"vis-container"})}export{ye as default};
